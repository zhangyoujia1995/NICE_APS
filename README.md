# 一级APS（高级计划与排程）系统原型

## 1. 项目简介

本项目是一个专为离散制造业设计的一级高级计划与排程（Level 1 APS）系统的核心算法原型。它旨在解决将客户订单智能地分配到多个工厂和不同生产周期中的复杂优化问题。

系统采用 **Python** 作为开发语言，并利用 **Google OR-Tools** (具体为 **CP-SAT** 求解器) 作为核心计算引擎，来处理带有复杂业务约束和多重优化目标的调度问题。

我们从零开始，采用模块化、产品化的软件工程思想，共同构建了一个结构清晰、功能完备且易于扩展的APS计算核心。

## 2. 已实现功能特性

-   **高度模块化的架构**: 系统的约束、目标、数据处理等核心部分均被设计为可独立修改、可插拔的模块，拥有极佳的可维护性和扩展性。
-   **多维产能约束**: 能够处理基于**多道工序**的精细化产能限制（例如，每个工厂的裁剪、缝纫、整烫工序都有各自独立的产能上限）。
-   **动态生产效率**: 支持根据**产品品类**和**订单数量**分档的生产效率模型。系统会为每个订单在不同工厂匹配最合适的效率，并动态计算其实际产能消耗。
-   **复杂的提前期计算**: 精确计算每个`(订单, 工厂)`组合的**总物料前置时间**，该时间综合了物料采购、分区域运输和生产准备三个部分。
-   **订单锁定（紧急插单）**: 支持对特定订单进行**强制性排程**。用户可以指定一个订单必须在：
    -   某个特定工厂生产。
    -   某个特定时间周期内生产。
    -   某个特定工厂的特定时间周期内生产。
-   **智能日期匹配 (“吸附”功能)**: 在锁定订单周期时，用户无需输入精确的周期开始日期。系统能够智能地判断用户提供的日期落在哪一个预设的生产周期内，并自动匹配。
-   **多目标优化**: 支持同时优化两个核心业务目标，并通过权重进行权衡：
    1.  **最大化准时交付率**: 关注服务水平，尽可能减少发生延误的订单**个数**。
    2.  **最小化JIT偏差**: 追求准时制生产，惩罚**提前**或**延误**的天数，使完成日期尽量贴近交付日期。
    3.  **最大化工厂负荷均衡**： 通过同时最小化“**最大负载率**”和“**最大-最小负载率差异**”，来实现削峰和均衡的双重目的。
-   **可配置的求解器**: 支持通过配置文件设置求解器的核心参数，如：
    -   求解时间上限 (`max_time_in_seconds`)。
    -   并行求解的核心数 (`num_search_workers`)。
-   **详细的过程日志**: 系统在运行的每个关键步骤都会输出详细的日志，并且可以开启求解器内部的搜索过程日志，便于调试和性能分析。
-   **KPI分析报告**: 在排程结束后，自动计算并输出关键性能指标，如**各工厂每个周期的负载率**，便于快速评估方案质量。

## 3. 系统架构

我们采用了您最初设计的优秀架构，并在此基础上进行了丰富和实现。

```

aps\_demo\_project/
├── core/                   \# 核心引擎模块
│   ├── runner.py           \# 业务流程执行器
│   ├── load\_data.py        \# 数据读取与结构化
│   ├── process\_data.py     \# 数据预处理
│   ├── solver.py           \# 求解器封装 (初始化CpModel和CpSolver)
│   ├── variable\_registry.py  \# 决策变量的创建与管理
│   └── store\_result.py     \# 结果处理、KPI计算与日志输出
├── constraints/            \# 约束条件模块 (可插拔)
│   ├── order\_unique\_assign.py \# 订单唯一分配约束
│   ├── capacity.py          \# 多工序产能约束
│   └── material\_lead\_time.py  \# 物料前置时间约束
├── objectives/             \# 优化目标模块 (可插拔)
│   ├── tardiness\_penalty.py   \# (原子目标) 计算延误订单
│   ├── just_in_time.py      \# (原子目标) 计算提前/延误总天数
│   ├── workload\_balance.py  \# (原子目标) 计算负载不均衡度
│   └── combined\_objective.py  \# (组合器) 动态融合各原子目标
├── config/                 \# 配置模块
│   └── settings.json       \# 全局配置文件
├── data/                   \# 输入数据模块
│   ├── orders.json         \# 订单数据
│   └── factories.json      \# 工厂数据
├── main.py                 \# 主调度入口程序
└── requirements.txt        \# Python 依赖库清单

````

## 4. 数据格式与配置

### `data/`
-   **factories.json**: 描述工厂属性，包括区域、周期性产能（按工序划分）、不同产品的生产效率（按数量分档）。
-   **orders.json**: 描述订单属性，包括产品品类、数量、交期、各项提前期、工序消耗，以及可选的`fixed_assignment`（用于锁定订单）。

### `config/settings.json`
该文件是系统的“控制面板”，允许用户调整：
-   **数据路径**: `data_paths`, `output_paths`。
-   **运行参数**: `run_config`，包括`base_date`（计划基准日）和`solver_time_limit_seconds`。
-   **JIT目标参数**: `jit_objective_config`，例如`allowed_deviation_days`，用于JIT偏差率的计算。
-   **激活的约束**: `active_constraints`列表，通过增删其中的字符串来启用或禁用不同的硬性约束。
-   **目标权重**: `objective_weights`，用于调整“准时交付”和“负载均衡”之间的优先级。

## 5. 安装与运行

### 安装依赖
```bash
pip install -r requirements.txt
````

*(当前 `requirements.txt` 中应包含 `google-ortools`)*

### 运行

确保`data`和`config`目录及文件已准备就绪，然后在项目根目录下执行：

```bash
python main.py
```

### 解读输出结果

程序执行后，您将在控制台看到几个主要部分的日志输出：

1.  **流程日志**: 按顺序显示数据加载、变量创建、约束和目标添加、求解等步骤的信息。
2.  **求解器日志**: 如果开启，会显示求解器寻找最优解的详细过程。
3.  **排程结果**: 逐一列出每个订单的分配详情，包括分配的工厂、周期、以及计算出的关键日期和是否延误。
4.  **KPI分析报告**: 在排程结果之后，会有一个专门的KPI报告部分，目前会按工厂展示每个周期的具体负载率（百分比和具体数值）。

## 6\. 模型逻辑总结
  - **决策变量**: 为每个可能的`(订单, 工厂, 周期)`组合创建一个布尔变量`x_ofp`。
  - **硬性约束**:
    1.  **唯一分配**: 每个订单的所有`x_ofp`变量总和必须等于1。
    2.  **物料前置时间**: 遍历所有变量，如果其代表的分配方案早于该订单的“最早可开工日期”，则添加约束强制该变量为0。
    3.  **多工序产能**: 对每个工厂、每个周期、每个工序，其总消耗（所有相关订单的`实际工作量 * x_ofp`之和）不得超过该工序的产能上限。
  - **优化目标**:
    1.  **延误订单**: 为每个订单创建一个“是否延误”的指示变量，通过约束将其与`x_ofp`关联。
    2.   **JIT偏差**: 为每个订单创建`earliness_days`和`tardiness_days`变量，计算提前和延误的天数总和，并内置0.3/0.7的惩罚权重。
    3.  **负载均衡**: 引入全局的“最大/最小负载率”变量，通过约束将它们与每个工厂周期的负载率关联。
    4.  **最大负载率**： 计算最大负载率，通过最小化最大负载率，结合2，使得订单均匀分布到所有工厂，减少极端负荷时间发生。
    5.  **组合目标**: 将所有激活的目标项（延误订单数、JIT偏差天数、负载不均衡度）各自转换为[0,1]范围内的标准化比率，然后根据配置的权重进行加权求和，形成最终的、求解器可以处理的浮点线性表达式。

## 7\. 下一步计划 

基于当前稳固的原型，未来可以从以下方向进行扩展：

  - **增加新约束**: 例如“最小起订量(MOQ)”、“颜色/尺寸组合约束”等。
  - **丰富优化目标**: 引入“最小化生产成本”、“最小化运输成本”等新的目标维度。
  - **架构与模型优化**:
      - **性能对比**: 在更大规模的数据集上，实现并对比**隐式约束**的真实性能。
      - **隐式约束**: 不通过在模型中添加具体的数学约束公式，而是在创建决策变量的阶段就从源头上排除掉所有不符合规则的可能性，从而更高效地强制模型遵守该规则（订单_工厂_时间周期变量中，根据base_date+lead_time，排除掉不可能的时间周期）。