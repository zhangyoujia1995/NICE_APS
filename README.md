# 一级APS（高级计划与排程）系统原型

## 1. 项目简介

本项目是一个专为离散制造业设计的一级高级计划与排程（Level 1 APS）系统的核心算法原型。它旨在解决将客户订单智能地分配到多个工厂和不同生产周期中的复杂优化问题。

系统采用 **Python** 作为开发语言，并利用 **Google OR-Tools** (具体为 **CP-SAT** 求解器) 作为核心计算引擎，来处理带有复杂业务约束和多重优化目标的调度问题。

我们从零开始，采用模块化、产品化的软件工程思想，共同构建了一个结构清晰、功能完备且易于扩展的APS计算核心。

## 2. 已实现功能特性 (Features)

-   **高度模块化的架构**: 系统的约束、目标、数据处理等核心部分均被设计为可独立修改、可插拔的模块，拥有极佳的可维护性和扩展性。
-   **多维产能约束**: 能够处理基于**多道工序**的精细化产能限制（例如，每个工厂的裁剪、缝纫、整烫工序都有各自独立的产能上限）。
-   **动态生产效率**: 支持根据**产品品类**和**订单数量**分档的生产效率模型。系统会为每个订单在不同工厂匹配最合适的效率，并动态计算其实际产能消耗。
-   **复杂的提前期计算**: 精确计算每个`(订单, 工厂)`组合的**总物料前置时间**，该时间综合了物料采购、分区域运输和生产准备三个部分。
-   **订单锁定（紧急插单）**: 支持对特定订单进行**强制性排程**。用户可以指定一个订单必须在：
    -   某个特定工厂生产。
    -   某个特定时间周期内生产。
    -   某个特定工厂的特定时间周期内生产。
-   **智能日期匹配 (“吸附”功能)**: 在锁定订单周期时，用户无需输入精确的周期开始日期。系统能够智能地判断用户提供的日期落在哪一个预设的生产周期内，并自动匹配。
-   **多目标优化**: 支持同时优化两个核心业务目标，并通过权重进行权衡：
    1.  **最大化准时交付率** (最小化延误订单数量)。
    2.  **最大化工厂负荷均衡** (最小化各工厂周期之间负载率的差异)。
-   **可配置的求解器**: 支持通过配置文件设置求解器的核心参数，如：
    -   求解时间上限 (`max_time_in_seconds`)。
    -   并行求解的核心数 (`num_search_workers`)。
-   **详细的过程日志**: 系统在运行的每个关键步骤都会输出详细的日志，并且可以开启求解器内部的搜索过程日志，便于调试和性能分析。

## 3. 系统架构 (Architecture)

我们采用了您最初设计的优秀架构，并在此基础上进行了丰富和实现。

```

aps\_demo\_project/
├── core/                   \# 核心引擎模块
│   ├── runner.py           \# 业务流程执行器 (总指挥)
│   ├── load\_data.py        \# 数据读取与结构化
│   ├── process\_data.py     \# 数据预处理
│   ├── solver.py           \# 求解器封装 (初始化CpModel和CpSolver)
│   ├── variable\_registry.py  \# 决策变量的创建与管理
│   └── store\_result.py     \# 结果处理与日志输出
├── constraints/            \# 约束条件模块 (可插拔)
│   ├── order\_unique\_assign.py \# 订单唯一分配约束
│   ├── capacity.py          \# 多工序产能约束
│   └── material\_lead\_time.py  \# 物料前置时间约束
├── objectives/             \# 优化目标模块 (可插拔)
│   ├── tardiness\_penalty.py   \# (原子目标) 计算延误订单
│   ├── workload\_balance.py  \# (原子目标) 计算负载不均衡度
│   └── combined\_objective.py  \# (组合器) 动态融合各原子目标
├── strategies/               \# 可插拔策略模块
│   └── lead\_time/            \# (为应对未来更复杂的规则预留)
│       ├── base.py
│       └── default.py
├── config/                 \# 配置模块
│   └── settings.json       \# 全局配置文件
├── data/                   \# 输入数据模块
│   ├── orders.json         \# 订单数据
│   └── factories.json      \# 工厂数据
├── main.py                 \# 主调度入口程序
└── requirements.txt        \# Python 依赖库清单

````

## 4. 数据格式与配置

### `data/`
-   **factories.json**: 描述工厂属性，包括区域、周期性产能（按工序划分）、不同产品的生产效率（按数量分档）。
-   **orders.json**: 描述订单属性，包括产品品类、数量、交期、各项提前期、工序消耗，以及可选的`fixed_assignment`（用于锁定订单）。

### `config/settings.json`
该文件是系统的“控制面板”，允许用户调整：
-   **数据路径**: `data_paths`, `output_paths`。
-   **运行参数**: `run_config`，包括`base_date`（计划基准日）和`solver_time_limit_seconds`。
-   **激活的约束**: `active_constraints`列表，通过增删其中的字符串来启用或禁用不同的硬性约束。
-   **目标权重**: `objective_weights`，用于调整“准时交付”和“负载均衡”之间的优先级。

## 5. 安装与运行

### 安装依赖
```bash
pip install -r requirements.txt
````

*(当前 `requirements.txt` 中应包含 `google-ortools`)*

### 运行

确保`data`和`config`目录及文件已准备就绪，然后在项目根目录下执行：

```bash
python main.py
```

程序将执行完整的APS计算流程，并将详细的日志和最终的排程结果打印到控制台。

## 6\. 模型逻辑总结

  - **决策变量**: 为每个可能的`(订单, 工厂, 周期)`组合创建一个布尔变量`x_ofp`。
  - **硬性约束**:
    1.  **唯一分配**: 每个订单的所有`x_ofp`变量总和必须等于1。
    2.  **物料前置时间**: 遍历所有变量，如果其代表的分配方案早于该订单的“最早可开工日期”，则添加约束强制该变量为0。
    3.  **多工序产能**: 对每个工厂、每个周期、每个工序，其总消耗（所有相关订单的`实际工作量 * x_ofp`之和）不得超过该工序的产能上限。
  - **优化目标**:
    1.  **延误订单**: 为每个订单创建一个“是否延误”的指示变量，通过约束将其与`x_ofp`关联。
    2.  **负载均衡**: 引入全局的“最大/最小负载率”变量，通过约束将它们与每个工厂周期的负载率关联。
    3.  **组合目标**: 将“延误订单总数”和“最大最小负载率之差”这两个目标项，根据配置的权重进行加权求和（并经过整数缩放），作为最终的`Minimize()`目标。

## 7\. 下一步计划 (Phase 2)

基于当前稳固的原型，未来可以从以下方向进行扩展：

  - **结果持久化**: 实现`core/store_result.py`的完整功能，将排程结果和关键日期输出为结构化的JSON文件。
  - **增加新约束**: 例如“最小起订量(MOQ)”、“颜色/尺寸组合约束”等。
  - **性能对比与调优**: 在大数据集下，切换回\*\*方案一（隐式约束）\*\*进行性能对比，以数据驱动决策。
  - **丰富优化目标**: 引入“最小化生产成本”、“最小化运输成本”等新的目标维度。

<!-- end list -->

```
```